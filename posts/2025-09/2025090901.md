---
title: 【题解】Luogu P1462 通往奥格瑞玛的道路
filename: 2025090901
tags:
  - 二分
  - 图论
  - 最短路
categories:
  - OI
date: 2025-09-09
description: 
articleGPT: 
cover: https://i1.wp.com/dev.ruom.top/i/2025/04/04/597560.webp
top:
share: true
delete:
---

20250904 模拟赛的题。\
其实这个题好像以前看《算法竞赛》的时候看到过，记得大概算法，所以做起来比较轻松（感觉挺简单，嗯不过本来就是）。

---

观察到 `其最小值为多少`，考虑二分。\
于是我们二分 `每条道路所经过的城市单次收费的最大值`。\
$\text{check}$ 的时候用 dijkstra：如果当前经过的城市要被收取的过路费比二分的 $\text{mid}$ 要大，就不走。\
（最短路是用来算最少要损失的血量）

注意：
- 跑 dij 之前先判断一下在第一个城市要被收取的过路费是否 $\leq \text{mid}$。
- `可能有两条边连接着相同的城市。`。

没了。

## Code
```cpp
#include<bits/stdc++.h>

typedef int IT;
typedef long long LL;
typedef __int128 int128;
typedef double DB;
typedef long double LDB;

#define pb push_back
#define fst first
#define sec second
#define psh push
#define mkp make_pair
#define PII pair<IT,IT>
#define PLI pair<LL,IT>
#define lowbit(x) ((x)&(-x))

// #define int long long

using namespace std;

const int N=4e4+10,M=5e4+10,ES=M<<1;
const int INF=1e9;

int n,m,b;
int f[N];
int mxf;

int ecnt,head[N],nxt[ES],to[ES],val[ES];
void add(int x,int y,int z){
    nxt[++ecnt]=head[x];
    head[x]=ecnt;
    to[ecnt]=y;
    val[ecnt]=z;
    return;
}

priority_queue<PLI,vector<PLI>,greater<PLI>>q;
LL dis[N];
bool vis[N];
bool check(int mxv){// mxv -> mxval
    while(!q.empty()) q.pop();
    for(int i=1;i<=n;i++) vis[i]=0,dis[i]=INF;

    if(f[1]>mxv) return 0;

    dis[1]=0ll;// f[1];
    q.psh({dis[1],1});

    while(!q.empty()){
        int u=q.top().sec;
        q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        if(dis[u]>b) continue;

        for(int i=head[u];i;i=nxt[i]){
            int v=to[i],w=val[i];
            // if(w>mxv) continue;
            if(f[v]>mxv) continue;
            if(dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                q.psh({dis[v],v});
            }
        }
    }

    // printf("dij---dis\n");
    // for(int i=1;i<=n;i++) printf("%d ",dis[i]);putchar('\n');

    return dis[n]<=b;
}

int main(){
    scanf("%d %d %d",&n,&m,&b);
    for(int i=1;i<=n;i++) scanf("%d",&f[i]),mxf=max(mxf,f[i]);

    for(int i=1;i<=m;i++){
        int x,y,z;
        scanf("%d %d %d",&x,&y,&z);
        if(x==y) continue;
        add(x,y,z),add(y,x,z);
    }

    int l=0,r=mxf,res=-1;
    while(l<=r){
        int mid=(l+r)>>1;
        // printf("l=%d, r=%d, mid=%d\n",l,r,mid);
        if(check(mid)) r=mid-1,res=mid;
        else l=mid+1;
    }
    
    if(res==-1) printf("AFK\n");
    else printf("%d\n",res);
    return 0;
}
```
[Link](https://www.luogu.com.cn/record/234306056)
